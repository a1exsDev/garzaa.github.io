---
layout: post
title:  "Basic Skeletal Animation in Unity"
---

I'm very lazy and dislike hand-animating. This is a problem in game development, so I have a workaround.

![img](/assets/skeletal/attacks.gif)

The above animation is skeletal instead of hand-drawn. Skeletal animation is nothing new, but at this resolution I can make it work effectively without looking like a mobile game.
The trick is to use skeletal animation and make it run  at a choppy 16 FPS, like most hand-drawn animations.

### Why?
Why not use sharper, smoother vector animations that run at a smooth 60 FPS? Because we like things that take effort. 
By lowering the visual fidelity, I'm _hinting_ that each frame is hand-drawn, which is more work than what I'm actually doing here.


## Process
##### 1. Add the pixel perfect camera
![img](/assets/skeletal/camera.png)

This is an official Unity asset available [here](https://docs.unity3d.com/Packages/com.unity.2d.pixel-perfect@1.0/manual/index.html). 
It renders everything to a smaller texture at runtime, so smooth edges will be automatically pixelated as they're reduced.

To save you the trouble of doing math, an 800Ã—450 target texture will work out to a pixel scale of 2:1 at 900p and 1080p.
I import my sprites normally at 100 PPU, so each pixel is 0.01 units wide inside Unity.


##### 2. Draw sprite atlas
![img](/assets/skeletal/8x atlas.png)

Hey, this looks large. This atlas is drawn at **8x** resolution and imported at **800 PPU**. That's because pixel art can't hold its shape when it gets rotated, or else it gets jagged.

![img](/assets/skeletal/rotsprite.png)

[RotSprite](https://en.wikipedia.org/wiki/Pixel-art_scaling_algorithms#RotSprite) is an algorithm for smoothly rotating pixel art. We can't do this at runtime in Unity, but we can mimic one of its essential steps: scaling a sprite up by 8x before applying the transform.


##### 3. "Rig"

![img](/assets/skeletal/rig.png)

Put each sprite's pivot where it connects to its parent limb. Bicep pivot goes on the shoulder, calf pivot on the knee, etc.

![img](/assets/skeletal/hierarchy.png)

Then build the hierarchy and shuffle sorting order as needed.


##### 4. Animate
![img](/assets/skeletal/animate1.png)

 ![img](/assets/skeletal/circlerenderer.png)

Build the character animation and use motion lines to signify when the hitboxes are active. Use a low sample count, this will be important later.

That motion line is a script wrapping a LineRenderer class.
```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(LineRenderer))]
public class CircleRenderer : LineRendererEditor {

	public int segments;
	[Range(0, 1)]
	public float arcFraction = 1f;
	public float radius = .10f;

	int segmentsLastFrame;
	float radiusLastFrame;
	float arcFractionLastFrame;

	override protected void Start() {
		base.Start();
		DrawCircle(segments);
		GetComponent<LineRenderer>().useWorldSpace = false;
	}

	void LateUpdate() {
		DrawCircle(segments);
		segmentsLastFrame = segments;
		radiusLastFrame = radius;
		arcFractionLastFrame = arcFraction;
	}

	bool Changed() {
		return segments != segmentsLastFrame || radius != radiusLastFrame || arcFraction != arcFractionLastFrame;
	}

	void DrawCircle(int segments) {
		Vector3[] points = new Vector3[segments];
                // fencepost error
		int actualSegments = (int) ((float) segments * arcFraction); 
		line.positionCount = actualSegments;
                // there's a better way to do this with Mathf.Deg2Rad, but I didn't know that existed when I was writing this
		for (int i=0; i<actualSegments; i++) {
			float angle =  ((float) i/segments) * Mathf.PI*2.0f;
			points[i] = new Vector3(
				Mathf.Sin(angle)*radius, 
				Mathf.Cos(angle)*radius, 
				0
			);
		}
		line.SetPositions(points);
	}
}
```
```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[RequireComponent(typeof(LineRenderer))]
public class LineRendererEditor : MonoBehaviour {
    protected LineRenderer line;

    virtual protected void Start() {
        line = GetComponent<LineRenderer>();
    }
}
```

![img](/assets/skeletal/streak.png)

The material on the motion line is very simple; it's this texture that's been stretched with the Sprites/Default renderer.

##### 5. Chop motion
I found this script online on the Unity forums and modified it to suit my needs. It affects the children of all of its transforms at runtime. 
If you want your character to move smoothly through the world with choppy sub-animations, make a child RigContainer object that contains the base rig and put the script on that.
```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ToonMotion : MonoBehaviour 
{
    private class Snapshot
    {
        public Transform transform;
        public Vector3 localPosition;
        public Quaternion localRotation;

        public Snapshot(Transform transform)
        {
            this.transform = transform;
            this.Update();
        }

        public void Update()
        {
            this.localPosition = this.transform.localPosition;
            this.localRotation = this.transform.localRotation;
        }
    }

    private Dictionary<int, Snapshot> snapshots = new Dictionary<int, Snapshot>();
    private float updateTime = 0f;

    public int fps = 20;

    bool forceUpdateThisFrame = false;

    private void LateUpdate()
    {
        if (forceUpdateThisFrame || Time.unscaledTime - this.updateTime > 1f/this.fps)
        {
            this.SaveSnapshot(transform);
            this.updateTime = Time.unscaledTime;
        }

        foreach(KeyValuePair<int, Snapshot> item in this.snapshots)
        {
            if (item.Value.transform != null)
            {
                item.Value.transform.localPosition = item.Value.localPosition;
                item.Value.transform.localRotation = item.Value.localRotation;
            }
        }

        forceUpdateThisFrame = false;
    }

    private void SaveSnapshot(Transform parent)
    {
        if (parent == null) return;
        int childrenCount = parent.childCount;

        for (int i = 0; i < childrenCount; ++i)
        {
            Transform target = parent.GetChild(i);
            int uid = target.GetInstanceID();

            this.snapshots[uid] = new Snapshot(target);
            this.SaveSnapshot(target);
        }
    }

    public void ForceUpdate() {
        forceUpdateThisFrame = true;
    }
}
```
